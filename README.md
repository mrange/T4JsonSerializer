# T4JsonSerializer
Generated Json Serialization code around Utf8Json* API

## Introduction

Microsoft asked us to [try the new source generator for JSON](https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-source-generator/).

The promise of a source generator for JSON serialization is that shorted startup as the generation code can be pre-generated during the build step rather than during runtime.

Also, source generators are less magic than dynamic type generation in .NET.

I inspected the generated code from the source generator and found that it did generate a quite nice serialize function but the deserializer relied on the metadata generated by the source generator.

Deserialization is rather complex as there's a need to specify converters and how to resolve property names as the JSON idiom is camel casing where in .NET it's pascal casing.

As a person interested in code generation I was wondering how well a version based around T4 would stack up against the new source generator especially if I took the freedom to ignore corner cases Microsoft had to consider for a generic source generator.

## T4 vs Source Generator

For me, source generators are too complex a machinery to bother with. I used T4 for 10+ years and is happy with it, I realize I am in a minority.

So when I need source generation I goto T4.

## The model

Source generators relies on the C# code as a model of what should be generated, a source generator developer traverses the analyzer tree from Roslyn to generate code.

While this has several benefits I do prefer defining a specialized model in T4 that only contain the information I need and nothing else.

Using C# code as model creates complexities for the source generator creator as C# code is more expressive than what makes sense for a the code generation and when needing additional metadata attributes has to be defined and used.

In this example I use this model to define my C# POCO records and serialize and deserialize methods.

```csharp
  var model = new []
  {
    C(  "Person"
      , ("int"                ,     "Id"        )
      , ("string"             ,     "FirstName" )
      , ("string"             ,     "LastName"  )
    ),
  };
```

It generates a POCO record like so:
```csharp
  partial record Person
  {
    public int    Id        { get; set; }
    public string FirstName { get; set; }
    public string LastName  { get; set; }
  }
```

This is matches the `Person` classed used in the blog post by Microsoft to do performance tests with.

In addition it generalize extension methods so that you can serialize and deserialize a `Person`.

```csharp
List<Person> SlowClone(List<Person> ps)
{
  // Serialize List<Person> to a JSON byte array
  byte[] bs = ps.Serialize();
  List<Person> pps;
  // Deserialize the JSON byte array into a List<Person>
  bs.Deserialize(out pps);
  return pps;
}
```

## The generator (T4)

Given the model the T4 code iterates over it and generate the POCO records and the serialize and deserialize methods. It's not very complicated as the model is simple, iterate over the model and generate code:

```
<# foreach (var classDef in model) { #>
  // --------------------------------------------------------------------------
  partial record <#=classDef.Name#>
  {
<# foreach (var (ptype, pname) in classDef.Properties) { #>
    public <#=RightPad(ptype, 20)#> <#=RightPad(pname, 30)#> { get; set; }
<# } #>
  }
  // --------------------------------------------------------------------------

<# } #>
```

This is the T4 code to generate the POCO records. It is basically PHP or old-school ASP.

One strong argument for source generators is good tooling that already exists. You reference a nuget package and annotate some classes with meta data and you are good.

For whatever reasons the tooling around T4 is poor and while it's possible to make reusable templates you have to figure out a way to distribute them. Nuget has been awkward for me and I usually rely on git submodules these days as a redistribution mechanism.

## Performance!

So how does it the T4 generated stack up against the source generator?

TBW

## Testing

Testing the generator is rather simple by using property based testing.

Property based testing is identifying properties in code that should always hold and a library like `FsCheck` then generates random test cases.

When it comes to serializers a property that is easy to understand is that if you serialize C# objects to JSON and back the deserialized objects should be value equal to original objects.

This can be expressed like a property test like this:

```fsharp
// FsCheck works in C# as well but I prefer F#
static member ``Person serialization round-trip`` (indented : bool) (ps : ResizeArray<Person>) =
  let ps  = fixPersons ps
  let e   = ps.ToArray ()
  let bs  = ps.Serialize indented
  let mutable a = ResizeArray<Person> ()
  bs.Deserialize &a
  let a = a.ToArray ()
  e = a
```

`FsCheck` will generate thousands of nasty test cases and the serializer and deserializer should work for all of them.

This together with a few strategic manual tests can give very good confidence.

